# TCP/IP网络模型

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png)

应用层：主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式。协议有http，用户态
传输层：负责向两台终端设备进程之间的通信提供通用的数据传输服务。使用协议：TCP UDP，以下都是内核态
网络层：负责为分组交换网上的不同主机提供通信服务，有IP协议。任务一：在发送数据时，网络层把传输层产生的报文段封装成分组和包进行传送。任务二：寻址，选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。
网络接口层：数据链路层+物理层。数据链路层：将网络层交下来的 IP 数据报组装成帧。物理层：实现相邻计算机节点之间二进制信号的传送，尽可能屏蔽掉具体传输介质和物理设备的差异。

应用层常见协议总结应用层协议 :

- HTTP 协议（超文本传输协议，网页浏览常用的协议）
- DHCP 协议（动态主机配置）
- DNS 系统原理（域名解析协议）
- FTP 协议（文件传输协议）
- Telnet协议（远程登陆协议）
- 电子邮件协议等（SMTP、POP3、IMAP）

网络接口层的传输单位是帧（frame），网络层的传输单位是包（packet），传输层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。

![img](https://pic3.zhimg.com/80/v2-3445959a0bf369bdeadf5ad855aec22a_720w.webp)





## 键入网址到网页显示，期间发生了什么

1.浏览器做的第一步工作是**解析 URL**，确定了 Web 服务器和文件名，从而生成发送给 `Web` 服务器的请求信息。

![image-20220823162717539](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220823162717539.png)

2.**DNS 解析****查询服务器域名对应的 IP 地址**，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。涉及域名解析。`www.server.com.`，这个最后的一个点代表根域名，.` 根域是在最顶层，它的下一层就是 `.com` 顶级域，再下面是 `server.com
域名解析流程：客户端->本地DNS服务器->根域名服务器->顶级域名服务器->权威域名服务器-返回本地DNS->客户端。
当然不是每次都这么麻烦，最先查浏览器缓存，2查操作系统缓存，3查hosts文件，这些都没有才问本地DNS。
![域名解析的工作流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/6.jpg)



3.与web服务器建立TCP连接。tcp三次握手。

TCP 协议通过三次握手建立连接。

- 客户端通过 `SYN` 报文段发送连接请求，确定服务端是否开启端口准备连接。客户端状态设置为 `SYN_SEND`;
- 服务器如果有开着的端口并且决定接受连接，就会返回一个 `SYN+ACK` 报文段给客户端，状态设置为 `SYN_RECV`；
- 客户端收到服务器的 `SYN+ACK` 报文段，向服务器发送 `ACK` 报文段表示确认。此时客户端和服务器都设置为 `ESTABLISHED` 状态。连接建立，可以开始数据传输了。

4.浏览器向web服务器发送http / https 请求获取页面。

5.服务器处理请求并返回http报文

6.浏览器解析渲染页面

7.断开连接-四次挥手



<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/url%E8%BE%93%E5%85%A5%E5%88%B0%E5%B1%95%E7%A4%BA%E5%87%BA%E6%9D%A5%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" alt="img" style="zoom:50%;" />

# HTTP

## HTTP 常见的状态码有哪些？

![ 五大类 HTTP 状态码 ](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.png)

3XX类状态码客户端请求的资源发生了变动，需要重定向获取。

301表示永久重定向，说明请求的资源已经不存在，需要改用新的url再次访问

302表示临时重定向，说明请求的资源还在，但暂时需要用另一个url来访问。



<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220823170615133.png" alt="image-20220823170615133" style="zoom: 67%;" />

## http报文格式

HTTP的请求报文由四部分组成（请求行+请求头部+空行+请求体）：·

![image-20231226221233340](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231226221233340.png)

![image-20231226221413703](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231226221413703.png)

![image-20231227113207578](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231227113207578.png)

## GET、POST区别

get:**GET 的语义是从服务器获取指定的资源**。GET 请求的参数位置一般是写在 URL 中，也就是浏览器地址栏容易看到。URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 URL 的长度有限制。

post:**POST 的语义是根据请求负荷（报文body）对指定的资源做出处理**。POST 请求携带数据的位置一般是写在报文 body 中， body 中的数据可以是任意格式的数据，无大小限制。虽然浏览器地址看不到post提交的数据，但是只要抓包就能知道。因此要安全需要https协议



## HTTP 缓存

HTTP 缓存有两种实现方式，分别是**强制缓存和协商缓存**。

**强制缓存**

强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存。如何判断过期？请求头的cache的相对过期时间

当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在Response头部加上（Cache-control）相对过期时间，当浏览器再次请求访问服务器中的该资源时，会先通过请求资源的时间与过期时间对比，是否该资源已过期。

![image-20220823172601272](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220823172601272.png)

**协商缓存**-类似版本号
![image-20220823173047715](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220823173047715.png)

## **HTTP 和 HTTPS 有什么区别？**

- **端口号** ：HTTP 默认是 80，HTTPS 默认是 443。

- **URL 前缀** ：HTTP 的 URL 前缀是 `http://`，HTTPS 的 URL 前缀是 `https://`。

- **安全性和资源消耗** ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 **SSL/TLS** 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。

  

### **HTTP的缺点**

HTTP 由于是明文传输，所以安全上存在以下三个风险：

- **窃听风险**，比如通信链路上可以获取通信内容，用户号容易没。
- **篡改风险**，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。
- **冒充风险**，比如冒充淘宝网站，用户钱容易没。

![image-20220823174957298](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220823174957298.png)

**https的混合加密**

![image-20220823174149820](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220823174149820.png)

非对称加密算法：DES AES
对称加密算法：RSA  ECC

公钥加密，私钥解密：保证内容传输的安全
私钥加密，公钥解密：保证消息不会被冒充，签名。

**https的摘要算法+数字签名**
摘要算法：为了保证传输的内容不被篡改，对内容计算出指纹，然后同内容一起传输。对方收到后，也计算指纹看是否符合。如果指纹不同，说明内容被篡改。
数字签名：哈希算法可以确保内容不会被篡改，**但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明**。所以采用数字签名(私钥加密)

**https的数字证书流程**

![数子证书工作流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)

数字证书流程：
1.服务器把公钥注册到CA
2.CA用自己的私钥将服务器的公钥数字签名并颁发数字证书
3.客户端拿到服务器的数字证书，使用CA的公钥确认真实性，CA公钥事先置入浏览器或者操作系统
4.从数字证书中获取服务器公钥，使用它对报文加密后发送给服务器，
5.服务器用私钥对报文解密



## HTTPS 是如何建立连接的

 [基于 RSA 握手过程的 HTTPS](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247487650&idx=1&sn=dfee83f6773a589c775ccd6f40491289&scene=21#wechat_redirect)
![HTTPS 连接建立过程](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)

简化版如下：

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/https%E4%B8%AD%E9%97%B4%E4%BA%BA.drawio.png)

**https双向认证**
如果用了双向认证方式，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81.png)

**基于ECDHE的https握手流程**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210303001034268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FydEFuZExpZmU=,size_16,color_FFFFFF,t_70#pic_center)

```
第一次握手：客户端发出clientHello消息，包括tls版本，支持的密码套件列表，和随机数A。

第二次握手：服务端收到客户端消息，返回serverHello，里面有确认的tls版本号，随机数B和选择的密码套件。接下来，为了证明自己的身份，发送certificate消息，把证书发给客户端。接着服务器生成服务端的椭圆曲线的私钥和公钥，发送serverkeyExchange消息，里面包含了椭圆曲线的选择和服务端的椭圆曲线的公钥。 最后 ServerHelloDone

第三次握手：客户端收到消息，生成客户端的椭圆曲线的私钥和公钥，并把公钥发给服务端。至此，双方都有对方的椭圆曲线公钥、自己的椭圆曲线私钥、椭圆曲线基点 G,计算出共享密钥。最终的会话密钥，就是用「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥）」三个材料生成的。算好会话密钥后，客户端会发一个「Change Cipher Spec」消息，告诉服务端后续改用对称算法加密通信。并把之前发送的数据做一个摘要发给服务端验证一下，验证本次生成的对称密钥是否正常使用。

第四次握手：服务端告诉服务端后续改用对称算法加密通信，并像上面那样发送消息摘要验证。
```



## HTTPS如何优化

```
https产生性能消耗的两个环节;
第一个环节， TLS 协议握手过程；第二个环节，握手后的对称加密报文传输。主要在第一个环节。
1.密钥交换算法优化：TLS 1.2版本如果使用的是 RSA 密钥交换算法，那么需要4次握手，慢。安全性不高。可选用ECDHE 密钥交换算法替换 RSA 算法，因为该算法由于支持「False Start」，它是“抢跑”的意思，客户端可以在 TLS 协议的第3次握手后，第4次握手前，发送加密的应用数据，以此将 TLS 握手的消息往返由2RTT减少到1RTT，而且安全性也高，具备前向安全性。

2.TLS升级：TLS1.3完成tls握手只需要1RTT。原理：Hello 和公钥交换这两个消息合并成了一个消息。

3.证书传输优化：服务器的证书应该选择椭圆曲线（ECDSA）证书，而不是 RSA 证书，因为在相同安全强度下， ECC 密钥长度比 RSA 短的多。

4.证书验证优化：客户端验证服务器的数字证书需要走证书链逐级验证。优化：服务器向 CA 周期性地查询证书状态，获得一个带有时间戳和签名的响应结果并缓存它。

5.会话复用
1.Session ID：客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识。缺点：服务器会越存越多。 由于服务器集群负载均衡机制，客户端再次连接不一定命中上次服务器。
2.Session Ticket：服务器不再缓存每个客户端的会话密钥，而是把缓存的工作交给了客户端。
原理：客户端与服务器首次建立连接时，服务器会加密「会话密钥」作为 Ticket 发给客户端，交给客户端缓存该 Ticket。
客户端再次连接服务器时，客户端会发送 Ticket，服务器解密后就可以获取上一次的会话密钥，然后验证有效期，如果没问题，就可以恢复会话了，开始加密通信。

```






## HTTP1.1 相比 HTTP1.0

```
HTTP/1.1 相比 HTTP/1.0 性能上的改进：
- 使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。
- 支持管道（pipeline）网络传输，客户端只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是服务端必须按照接收请求的顺序发送响应，会出现队头阻塞。 管道只解决了请求的队头阻塞，没有解决响应的队头阻塞。

但 HTTP/1.1 还是有性能瓶颈：
- 请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 `Body` 的部分；
- 发送冗长的首部。每次互相发送相同的首部造成的浪费较多；
- 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；
- 没有请求优先级控制；
- 请求只能从客户端开始，服务器只能被动响应
```

## HTTP/2 做了什么优化？

```
1. 头部压缩
HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。
这就是所谓的 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

2. 二进制格式
HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧（Headers Frame）和数据帧（Data Frame）。增加了数据传输的效率。

3. 数据流
HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。优先级控制：客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。

4. 多路复用
HTTP/2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。
5. 服务器推送
HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务端不再是被动地响应，可以主动向客户端发送消息。
```

# TCP

## TCP 与 UDP 的区别

```
TCP 与 UDP 的区别（重要）
1是否面向连接 ：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。
2是否是可靠传输：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。
3是否有状态 ：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（这很渣男！）。
4传输效率 ：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。
5传输形式 ： TCP 是面向字节流的，没有边界，UDP 是面向报文的。
6首部开销 ：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。
7是否提供广播或多播服务 ：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；
```

![image-20220823181155435](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220823181155435.png)

## TCP三次握手

![TCP 三次握手](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png)

```
ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。
RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。
SYN：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。
FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。

三次握手流程：
1.一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态
2.客户端会随机初始化序号（client_isn），将此序号置于 TCP 首部的「序号」字段中，同时把 SYN 标志位置为 1 ，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态。（第一次握手）
3.服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1, 接着把 SYN 和 ACK 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。（第二次握手）
4.客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 ESTABLISHED 状态。（第三次握手）
5.服务器收到客户端的应答报文后，也进入 ESTABLISHED 状态。
```



### 为什么是三次握手？不是两次、四次？

```
原因一：避免历史连接
三次握手的首要原因是为了防止旧的重复连接初始化造成混乱--RFC793指出。主要是因为在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费。
场景：客户端先发了syn+90的报文，但是被网络阻塞，再发了syn+100的报文，此时旧的syn比新的先抵达。服务器就返回syn+ack+91报文给客户端，客户端发现acknum不正确，所以发起rst报文中止连接。
如果是两次握手情况下，服务端在收到SYN报文后，就进入ESTABLISHED状态，意味着这时可以给客户端发送数据。而如果客户端如果发现本次连接是历史连接，就会回RST报文断开连接。但服务端已经处于已建立状态，所以造成资源浪费。


原因二：同步双方初始序列号
序列号作用：1.接收方去除重复数据， 2接收方根据数据包序列号按序接收，3可以标识数据包哪些被正常接收
当客户端发送携带「初始序列号」的 SYN 报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样一来一回，才能确保双方的初始序列号能被可靠的同步。

原因三：避免资源浪费
如果客户端的 SYN 阻塞了，重复发送多次 SYN 报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。
```

### 为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？

```
1为了防止历史报文被下一个相同四元组的连接接收（主要方面）；
如果每次建立连接客户端和服务端的初始化序列号都「一样」，就有大概率遇到历史报文的序列号刚「好在」对方的接收窗口内，从而导致历史报文被新连接成功接收。
客户端和服务端的初始化序列号都是随机生成，能很大程度上避免历史报文被下一个相同四元组的连接接收，然后又引入时间戳的机制，从而完全避免了历史报文被接收的问题。
2为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；
```

### 第一次握手丢失了，会发生什么？

```
如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文。
在 Linux 里，客户端的 SYN 报文最大重传次数由 tcp_syn_retries内核参数控制，这个参数是可以自定义的，默认值是5。
通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。 1,2,4,8,16
```

### 第二次握手丢失了，会发生什么？

```
客户端会重传 SYN 报文（第一次握手）， 服务端会重传 SYN-ACK 报文（第二次握手）

第三次握手丢失
服务端触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。
```



### Socket编程与握手对应关系

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/socket%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="socket 三次握手" style="zoom:50%;" />

**客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后**。





## 半连接队列和全连接队列

```
正常流程：   syn队列--半连接队列    accept队列--全连接队列
当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」；
接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；
服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」；
应用通过调用 accpet() socket 接口，从「 Accept 队列」取出连接。

1.如何增大TCP全连接队列:TCP 全连接队列的最大值 = min(somaxconn, backlog)
2.如果 SYN 半连接队列已满，只能丢弃连接吗？ 默认是丢弃连接，可以开启syncookies，达到不使用 SYN 半连接队列的情况下成功建立连接。
syncookies原理：服务器根据当前状态计算一个值cookie，放在己方发出的SYN+ACK报文。当收到客户端返回ACK报文时，验证ack包的合法性，如果合法就认为连接建立成功，把连接对象放到全连接队列。相当于绕过半连接队列。
3.如果全连接队列都满了，只能丢弃后续的请求。

SYN 攻击：
1.增大半连接队列
2.开启syncookies
3.减少SYN+ACK重传次数：让重传次数超过上限的连接加快断开

如果全连接队列满了，会默认丢弃新来的第三次握手ACK.除此之外，会受tcp_abort_on_overflow 参数的影响
tcp_abort_on_overflow =0；不仅丢弃第三次握手的ACK，并且开启定时器，重传第二次握手SYN+ACK。如果重传超过限制次数，还会把对应的半连接队列的连接删掉
tcp_abort_on_overflow =1；直接发RST给客户端
```

![正常流程](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzI2LmpwZw?x-oss-process=image/format,png)



## TCP四次挥手

<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzMwLmpwZw?x-oss-process=image/format,png" alt="客户端主动关闭连接 —— TCP 四次挥手" style="zoom:80%;" />

```
流程：
1.客户端打算关闭连接，此时会发送一个TCP首部FIN标志位被置为1的报文，即FIN报文，之后客户端进入FIN_WAIT_1状态。
2.服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSED_WAIT 状态。
3.客户端收到服务端的ACK应答报文后，进入FIN_WAIT_2 状态。
4.等待服务端处理完数据后，也向客户端发送FIN报文，之后服务端进入LAST_ACK 状态。
5.客户端收到服务端的FIN报文后，回一个ACK应答报文，至此服务端已经完成连接的关闭。
6.客户端在经过 2MSL 一段时间后，自动进入 CLOSED 状态，至此客户端也完成连接的关闭。 （msl）报文最大生存时间 30秒
```

```
为什么挥手需要四次？
关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。
服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。ACK报文和FIN分开发送，比三次握手多一次

第一次挥手丢失  客户端重传FIN报文
第二次挥手丢失  由于ACK报文不会重传，客户端重传FIN报文
第三次挥手丢失  服务端由于没有收到ACK报文，会重传FIN报文
第四次挥手丢失  服务端由于没有收到ACK报文，会重传FIN报文
```

###  为什么 TIME_WAIT 等待的时间是 2MSL？

```
网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。可以看到2msl的机制是允许最后的ack报文至少丢失一次。
比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 FIN 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。
```

### TIME_WAIT状态作用

```
原因一：防止历史连接中的数据，被后面相同四元组的连接错误的接收。
2MSL足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。
原因二：保证服务端的一方，能被正确的关闭
TIME-WAIT 作用是等待足够的时间以确保最后的 ACK 能让服务器关闭方接收，从而帮助其正常关闭。

TIME_WAIT 过多有什么危害？第一是占用系统资源，第二是占用端口资源
```



### 连接后，某一方故障，保活机制

```
保活机制：
tcp_keepalive_time=7200：表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制
tcp_keepalive_intvl=75：表示每次检测间隔 75 秒；
tcp_keepalive_probes=9：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。
```

![image-20220823221930549](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220823221930549.png)



## TCP重传机制

**包括超时重传，快速重传，SACK , D-SACK**

### 超时重传

发送方超过规定的时间还没收到ack应答报文，认为报文丢失，就会重传。**超时重传时间 RTO 的值应该略大于报文往返 RTT 的值**。由于网络波动，因此RTO是动态变化的值估计往返时间，通常需要采样以下两个：

- 需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个平滑 RTT 的值，而且这个值还是要不断变化的，因为网络状况不断地变化。
- 除了采样 RTT，还要采样 RTT 的波动范围，这样就避免如果 RTT 有一个大的波动的话，很难被发现的情况。

如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是**超时间隔加倍。**

### **快速重传**

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/10.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="快速重传机制" style="zoom: 67%;" />

```
1.第一份 Seq1 先送到了，于是就 Ack 回 2；
2.结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；
3.后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；
4.发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。
5.最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。
快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。
```

快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是**重传的时候，是重传一个，还是重传所有的问题。**
1.由此引入 SACK（选择性确认）方法，这种方式需要在TCP头部字段加一个SACK，标记接收方已收到的数据信息发给发送方，这样发送方就可以只重传丢失的数据。
2.D-SACK（Duplicate SACK），其主要**使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。**好处：发送方知道是发出去包丢了还是接收方回应的ACK包丢了。



## 滑动窗口

一发一确认的收发机制效率比较低，所以tcp引入了窗口的概念，窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。这样就要求发送方主机在等待确认应答返回之前，需要在缓冲区保留已发送的数据，收到确认应答的消息才删除缓存数据。

TCP 头里有一个字段叫 `Window`，也就是窗口大小。

**这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。**

所以，通常窗口的大小是由接收方的窗口大小来决定的

滑动窗口的过程-发送方的滑动窗口

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/16.jpg?)



```
背诵流程：
问题：一发一确认的收发机制效率比较低，所以tcp引入了窗口的概念，窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。通常窗口的大小是由接收方的窗口大小来决定的。
1.可以把滑动窗口分为已发送窗口和可用窗口，已发送窗口的数据是已发送但未收到ACK确认的数据，可用窗口是未发送但总大小在接收方处理范围内的。如滑动窗口大小为100，已发送窗口为50，可用窗口为50.
2.当发送方把全部数据都发送出去，可用窗口大小变为0，表明可用窗口耗尽，在没有收到ACK确认之前是无法继续发送数据
3.如果这个时候收到了之前发送的数据有ack后，滑动窗口向右移动，又可以继续发送。
```



<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/25.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="窗口探测" style="zoom:67%;" />

**糊涂窗口综合征**

如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小。

到最后，**如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症**。而tcp+ip头有40个字节，为了传输一点点数据，搭上这么大开销，相当于高铁只拉一个人。

解决糊涂窗口综合征

- 让接收方不通告小窗口给发送方--窗口大小 >= MSS，或者接收方缓存空间有一半可以使用才打开窗口
- 让发送方避免发送小数据--要等到窗口大小 >= `MSS` 并且 数据大小 >= `MSS`



## 拥塞控制

前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。
原因目的：而**拥塞控制**，控制的目的就是**避免「发送方」的数据填满整个网络**。在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，

**拥塞窗口**：**拥塞窗口 cwnd**是发送方维护的一个的状态变量，它会根据**网络的拥塞程度动态变化的**。
发送窗口=min(接收窗口， 拥塞窗口)。拥塞窗口变化的规则：只要网络中没有出现拥塞，cwnd就增大，否则减少。

怎么知道当前网络是否出现了拥塞？ 只要发送方没有在规定时间收到ack应答报文，就是发生超时重传，即网络拥塞。

**拥塞控制的四个算法：慢启动、拥塞避免、拥塞发生、快速恢复**

```
1.慢启动的算法记住一个规则就行：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。指数增加，直到慢启动门限
2.拥塞避免：每当收到一个 ACK 时，cwnd 增加 1/cwnd。线性增长。
3.拥塞发生：分两种重传机制讨论，第一种：发生超时重传的拥塞发生--慢启动门限设为cwnd/2,cwnd重置为初始值=10。
4.						  第二种：发生快重传的拥塞发生--cwnd=cwnd/2,慢启动门限=cwnd,然后进入快速恢复算法
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220823230959841.png" alt="image-20220823230959841" style="zoom: 80%;" />

首先，快速恢复第一步的目的是减少拥塞窗口来降低拥塞，然后拥塞窗口逐渐+1的目的是为了尽快将丢失的数据包发送给目标，从而解决拥塞的根本问题（三次相同的ACK导致的快速重传），所以这一过程拥塞窗口是逐渐增大的。

![快速重传和快速恢复](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)





## TCP优化

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/3.jpg" alt="本节提纲" style="zoom:50%;" />

### TCP三次握手的性能提升

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/24.jpg" alt="三次握手优化策略" style="zoom:50%;" />

```
客户端的优化
当客户端发起 SYN 包时，可以通过 tcp_syn_retries 控制其重传的次数。

服务端的优化
当服务端 SYN 半连接队列溢出后，会导致后续连接被丢弃，可以通过 netstat -s 观察半连接队列溢出的情况，如果 SYN 半连接队列溢出情况比较严重，可以通过 tcp_max_syn_backlog、somaxconn、backlog 参数来调整 SYN 半连接队列的大小。

服务端回复 SYN+ACK 的重传次数由 tcp_synack_retries 参数控制。如果遭受 SYN 攻击，应把 tcp_syncookies 参数设置为 1，表示仅在 SYN 队列满后开启 syncookie 功能，可以保证正常的连接成功建立。

服务端收到客户端返回的 ACK，会把连接移入 accpet 队列，等待进行调用 accpet() 函数取出连接。

可以通过 ss -lnt 查看服务端进程的 accept 队列长度，如果 accept 队列溢出，系统默认丢弃 ACK，如果可以把 tcp_abort_on_overflow 设置为 1 ，表示用 RST 通知客户端连接建立失败。

如果 accpet 队列溢出严重，可以通过 listen 函数的 backlog 参数和 somaxconn 系统参数提高队列大小，accept 队列长度取决于 min(backlog, somaxconn)。

绕过三次握手
TCP Fast Open 功能可以绕过三次握手，使得 HTTP 请求减少了 1 个 RTT 的时间，Linux 下可以通过 tcp_fastopen 开启该功能，同时必须保证服务端和客户端同时支持。
```



## TCP 面向字节流

```
当用户消息通过 TCP 协议传输时，消息可能会被操作系统分组成多个的 TCP 报文，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。接收方的程序如果不知道发送方发送的消息的长度（消息边界），是无法读出一个有效的用户消息的。

1.如何解决粘包问题？
a.特殊字符作为边界   b.自定义消息结构（包头有字段说明数据长度） c固定长度的消息

```



## SYN 报文什么时候情况下会被丢弃

```
SYN 报文被丢弃的两种场景：
1.开启 tcp_tw_recycle 参数(允许处于TIME_WAIT状态的连接被快速回收)，并且在 NAT 环境下，造成 SYN 报文被丢弃
2.TCP 两个队列满了（半连接队列和全连接队列），造成 SYN 报文被丢弃

TIME_WAIT 状态也不是摆设作用，它的作用有两个：
1.防止具有相同四元组的旧数据包被收到，也就是防止历史连接中的数据，被后面的连接接受，否则就会导致后面的连接收到一个无效的数据，
2.保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭;
```



## 已建立连接的TCP，收到SYN会发生什么？

```
问题：一个已经建立的 TCP 连接，客户端中途宕机了，而服务端此时也没有数据要发送，一直处于 establish 状态，客户端恢复后，向服务端建立连接，此时服务端会怎么处理？根据四元组相同还是不相同来区分
1.客户端的 SYN 报文里的端口号与历史连接不相同      2. 客户端的 SYN 报文里的端口号与历史连接相同
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220825204117058.png" alt="image-20220825204117058"  />

2. 客户端的 SYN 报文里的端口号与历史连接相同
   处于 establish 状态的服务端如果收到了客户端的 SYN 报文(随机的初始化序列号)，会回复一个携带了正确序列号和确认号的 ACK 报文，这个 ACK 被称之为 Challenge ACK。客户端收到这个 Challenge ACK，发现序列号并不是自己期望收到的，于是就会回 RST 报文，服务端收到后，就会释放掉该连接。

   ## 

## 在 FIN_WAIT_2 状态下，是如何处理收到的乱序的FIN 报文

```
1.在 FIN_WAIT_2 状态时，如果收到乱序的 FIN 报文，那么就被会加入到「乱序队列」，并不会进入到 TIME_WAIT 状态。
2.等再次收到前面被网络延迟的数据包时，会判断乱序队列有没有数据，然后会检测乱序队列中是否有可用的数据。
3.如果能在乱序队列中找到与当前报文的序列号保持的顺序的报文，就会看该报文是否有 FIN 标志，如果发现有 FIN 标志，这时才会进入 TIME_WAIT 状态。
```

<img src="https://img-blog.csdnimg.cn/4effcf2a9e7e4adeb892da98ee21694b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5p6XY29kaW5n,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom: 67%;" />



## TCP 的 Keepalive 和 HTTP 的 Keep-Alive

```
1.TCP 的 Keepalive，是由 TCP 层（内核态） 实现的，称为 TCP 保活机制；
2.HTTP 的 Keep-Alive，是由应用层（用户态） 实现的，称为 HTTP 长连接；HTTP 1.1，默认是开启了 Keep-Alive
长连接好处：少了 TCP 连接资源的开销，同一个tcp连接来发送和接收多个HTTP的请求应答
```

## TCP协议的缺陷

```
1.升级 TCP 的工作很困难；
TCP 协议是在内核中实现的，应用程序只能使用不能修改。要升级tcp协议，就要升级内核

2.TCP 建立连接的延迟；
3次握手+四次tls握手

3.TCP 存在队头阻塞问题；
TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且有序的，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据。发送窗口队头阻塞，接收窗口队头阻塞

4.网络迁移需要重新建立 TCP 连接；
基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。所以如果从4G切换到WiFi，意味着四元组变了，重新建立tcp
```



## TCP 和 UDP 可以同时绑定相同的端口吗

```
可以
传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块。
当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。
因此， TCP/UDP 各自的端口号也相互独立，如 TCP 有一个 80 号端口，UDP 也可以有一个 80 号端口，二者并不冲突。
```



## 客户端的端口可以重复使用吗

```
TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的。
所以如果客户端已使用端口 64992 与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口 64992 的，因为内核是通过四元祖信息来定位一个 TCP 连接的，并不会因为客户端的端口号相同，而导致连接冲突的问题。
```



## 服务端没有 listen，客户端发起连接建立，会发生什么

**服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文**



## 没有 listen，能建立 TCP 连接吗

```
1.是可以的，客户端是可以自己连自己的形成连接（TCP自连接），也可以两个客户端同时向对方发出请求建立连接（TCP同时打开），这两个情况都有个共同点，就是没有服务端参与，也就是没有listen，就能建立连接。
2.执行listen 方法时，会自动创建半连接队列和全连接队列。用于三次握手过程中暂存连接信息。
3.客户端没有执行listen方法，因此没有连接队列。但内核还有个全局 hash 表，可以用于存放 sock 连接的信息。
```



## TCP协议常见丢包场景

```
1建立连接时丢包：半连接与全连接队列满的情况下会丢包
2流量控制丢包：让数据按照一定的规则排个队依次进入网卡处理，如果发送数据过快，流控队列被打满就容易丢包。

3.网卡的RingBuffer过小导致丢包：接收数据时，数据会暂存在RingBuffer接收缓冲区中，然后等着内核触发软中断慢慢收走，如果这个缓冲区过小，而这时发送的数据又过快，就可能溢出。

4.接收缓冲区丢包：详情见接收窗口，如果接收窗口为0，此时发送方仍继续发送，则溢出丢包。

TCP只保证传输层的消息可靠性，并不保证应用层的消息可靠性。如果我们还想保证应用层的消息可靠性，就需要应用层自己去实现逻辑做保证。
```

## 在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？

针对这个问题，**关键是要看 SYN 的「序列号和时间戳」是否合法**

收到合法的SYN:如果处于 TIME_WAIT 状态的连接收到「合法的 SYN 」后，**就会重用此四元组连接，跳过 2MSL 而转变为 SYN_RECV 状态，接着就能进行建立连接过程**。

收到非法的SYN:如果处于 TIME_WAIT 状态的连接收到「非法的 SYN 」后，就会**再回复一个第四次挥手的 ACK 报文，客户端收到后，发现并不是自己期望收到确认号（ack num），就回 RST 报文给服务端**。



# ping的工作原理

```
ping 是基于 ICMP 协议工作的
ICMP 主要的功能包括：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。
```

![image-20220826165113550](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220826165113550.png)

查询报文类型：类型0 和类型8
**回送消息**用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息，`ping` 命令就是利用这个消息实现的。

# 短链接设计方案

什么是 URL 短链

URL 短链，就是把原来较长的网址，转换成比较短的网址。我们可以在短信和微博里可以经常看到短链的身影。

例如： [https://j.mp/38Zx5XC](https://link.zhihu.com/?target=https%3A//j.mp/38Zx5XC) ，就是一条短链。 用户点击蓝色的短链，就可以在浏览器中看到它对应的原网址：

那么为什么要做这样的转换呢？来看看短链带来的好处：

- 在微博， Twitter 这些限制字数的应用中，短链带来的好处不言而喻： 网址短、美观、便于发布、传播，可以写更多有意义的文字；
- 在短信中，如果含长网址的短信内容超过 70 字，就会被拆成两条发送，而用短链则可能一条短信就搞定，如果短信量大也可以省下不少钱；
- 我们平常看到的二维码，本质上也是一串 URL ，如果是长链，对应的二维码会密密麻麻，扫码的时候机器很难识别，而短链则不存在这个问题；
- 出于安全考虑，不想让有意图的人看到原始网址。

**短链跳转主要原理**

\1. 客户端（或浏览器）请求短链： [https://j.mp/38Zx5XC](https://link.zhihu.com/?target=https%3A//j.mp/38Zx5XC)

\2. 短链服务器收到请求后，返回 status code: 301 或 302 ，说明需要跳转，同时也通过 location 字段告知客户端：你要访问的其实是下面这个长网址 ：
[https://activity.icoolread.com/act7/212/duanxin/index](https://link.zhihu.com/?target=https%3A//activity.icoolread.com/act7/212/duanxin/index)

- 301永久重定向会导致浏览器缓存重定向地址，短链接系统统计访问次数会不正确
- 302临时重定向可以解决次数不准的问题，但是每次都会到短链接系统转换，服务器压力会变大。

\3. 客户端收到短链服务器的应答后，再去访问长网址：
[https://activity.icoolread.com/](https://link.zhihu.com/?target=https%3A//activity.icoolread.com/act7/212/duanxin/index)

**设计方案**

1.全局发号器

使用数据库、redis 里的一条数据存储长链接和短链接（id）的映射关系。缺点：递增的数字id，不安全，规律性太强了

2.id 转换策略

为了缩短链接的长度，我们必须把`id`转换掉，比如我们的短链接由`a-z`,`A-Z`,`0-9`组成，相当于`62`进制的数字，将`id`转换成为`62`进制的数字:

3.Hash算法
